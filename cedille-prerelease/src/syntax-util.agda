module syntax-util where

open import lib
open import cedille-types
open import general-util

posinfo-gen : posinfo
posinfo-gen = "generated"

first-position : posinfo
first-position = "1"

dummy-var : var
dummy-var = "_dummy"

id-term : term
id-term = Lam posinfo-gen KeptLambda posinfo-gen "x" NoClass (Var posinfo-gen "x")

compileFailType : type
compileFailType = Abs posinfo-gen All posinfo-gen "X" (Tkk (Star posinfo-gen))  (TpVar posinfo-gen "X")

delta-contra =
  let lambda x = Lam posinfo-gen KeptLambda posinfo-gen x NoClass in
  TpEq
    posinfo-gen
    (lambda "x" (lambda "y" (Var posinfo-gen "x")))
    (lambda "x" (lambda "y" (Var posinfo-gen "y")))
    posinfo-gen

qualif-info : Set
qualif-info = var √ó args

qualif : Set
qualif = trie qualif-info

tag : Set
tag = string √ó rope

tagged-val : Set
tagged-val = string √ó rope √ó ùïÉ tag

tags-to-rope : ùïÉ tag ‚Üí rope
tags-to-rope [] = [[]]
tags-to-rope ((t , v) :: []) = [[ "\"" ^ t ^ "\":" ]] ‚äπ‚äπ v
tags-to-rope ((t , v) :: ts) = [[ "\"" ^ t ^ "\":" ]] ‚äπ‚äπ v ‚äπ‚äπ [[ "," ]] ‚äπ‚äπ tags-to-rope ts

-- We number these when so we can sort them back in emacs
tagged-val-to-rope : ‚Ñï ‚Üí tagged-val ‚Üí rope
tagged-val-to-rope n (t , v , []) = [[ "\"" ^ t ^ "\":[\"" ^ ‚Ñï-to-string n ^ "\",\"" ]] ‚äπ‚äπ v ‚äπ‚äπ [[ "\"]" ]]
tagged-val-to-rope n (t , v , tags) = [[ "\"" ^ t ^ "\":[\"" ^ ‚Ñï-to-string n ^ "\",\"" ]] ‚äπ‚äπ v ‚äπ‚äπ [[ "\",{" ]] ‚äπ‚äπ tags-to-rope tags ‚äπ‚äπ [[ "}]" ]]

tagged-vals-to-rope : ‚Ñï ‚Üí ùïÉ tagged-val ‚Üí rope
tagged-vals-to-rope n [] = [[]]
tagged-vals-to-rope n (s :: []) = tagged-val-to-rope n s
tagged-vals-to-rope n (s :: (s' :: ss)) = tagged-val-to-rope n s ‚äπ‚äπ [[ "," ]] ‚äπ‚äπ tagged-vals-to-rope (suc n) (s' :: ss)


make-tag : (name : string) ‚Üí (values : ùïÉ tag) ‚Üí (start : ‚Ñï) ‚Üí (end : ‚Ñï) ‚Üí tag
make-tag name vs start end = name , [[ "{\"start\":\"" ^ ‚Ñï-to-string start ^ "\",\"end\":\"" ^ ‚Ñï-to-string end ^ "\"" ]] ‚äπ‚äπ vs-to-rope vs ‚äπ‚äπ [[ "}" ]]
  where
    vs-to-rope : ùïÉ tag ‚Üí rope
    vs-to-rope [] = [[]]
    vs-to-rope ((t , v) :: ts) = [[ ",\"" ^ t ^ "\":\"" ]] ‚äπ‚äπ v ‚äπ‚äπ [[ "\"" ]] ‚äπ‚äπ vs-to-rope ts

posinfo-to-‚Ñï : posinfo ‚Üí ‚Ñï
posinfo-to-‚Ñï pi with string-to-‚Ñï pi
posinfo-to-‚Ñï pi | just n = n
posinfo-to-‚Ñï pi | nothing = 0 -- should not happen

posinfo-plus : posinfo ‚Üí ‚Ñï ‚Üí posinfo
posinfo-plus pi n = ‚Ñï-to-string (posinfo-to-‚Ñï pi + n)

posinfo-plus-str : posinfo ‚Üí string ‚Üí posinfo
posinfo-plus-str pi s = posinfo-plus pi (string-length s)

star : kind
star = Star posinfo-gen

-- qualify variable by module name
_#_ : string ‚Üí string ‚Üí string
fn # v = fn ^ "." ^  v

_%_ : posinfo ‚Üí var ‚Üí string
pi % v = pi ^ "@" ^ v

compileFail : var
compileFail = "compileFail"
compileFail-qual = "" % compileFail

mk-inst : params ‚Üí args ‚Üí trie arg √ó params
mk-inst (ParamsCons (Decl _ _ x _ _) ps) (ArgsCons a as) with mk-inst ps as
...| œÉ , ps' = trie-insert œÉ x a , ps'
mk-inst ps as = empty-trie , ps

apps-term : term ‚Üí args ‚Üí term
apps-term f (ArgsNil) = f
apps-term f (ArgsCons (TermArg t) as) = apps-term (App f NotErased t) as
apps-term f (ArgsCons (TypeArg t) as) = apps-term (AppTp f t) as

apps-type : type ‚Üí args ‚Üí type
apps-type f (ArgsNil) = f
apps-type f (ArgsCons (TermArg t) as) = apps-type (TpAppt f t) as
apps-type f (ArgsCons (TypeArg t) as) = apps-type (TpApp f t) as

append-params : params ‚Üí params ‚Üí params
append-params (ParamsCons p ps) qs = ParamsCons p (append-params ps qs)
append-params ParamsNil qs = qs

append-args : args ‚Üí args ‚Üí args
append-args (ArgsCons p ps) qs = ArgsCons p (append-args ps qs)
append-args (ArgsNil) qs = qs

qualif-lookup-term : posinfo ‚Üí qualif ‚Üí string ‚Üí term
qualif-lookup-term pi œÉ x with trie-lookup œÉ x
... | just (x' , as) = apps-term (Var pi x') as
... | _ = Var pi x

qualif-lookup-type : posinfo ‚Üí qualif ‚Üí string ‚Üí type
qualif-lookup-type pi œÉ x with trie-lookup œÉ x
... | just (x' , as) = apps-type (TpVar pi x') as
... | _ = TpVar pi x

qualif-lookup-kind : posinfo ‚Üí args ‚Üí qualif ‚Üí string ‚Üí kind
qualif-lookup-kind pi xs œÉ x with trie-lookup œÉ x
... | just (x' , as) = KndVar pi x' (append-args as xs)
... | _ = KndVar pi x xs

inst-lookup-term : posinfo ‚Üí trie arg ‚Üí string ‚Üí term
inst-lookup-term pi œÉ x with trie-lookup œÉ x
... | just (TermArg t) = t
... | _ = Var pi x

inst-lookup-type : posinfo ‚Üí trie arg ‚Üí string ‚Üí type
inst-lookup-type pi œÉ x with trie-lookup œÉ x
... | just (TypeArg t) = t
... | _ = TpVar pi x

params-to-args : params ‚Üí args
params-to-args ParamsNil = ArgsNil
params-to-args (ParamsCons (Decl _ p v (Tkt t) _) ps) = ArgsCons (TermArg (Var p v)) (params-to-args ps)
params-to-args (ParamsCons (Decl _ p v (Tkk k) _) ps) = ArgsCons (TypeArg (TpVar p v)) (params-to-args ps)

qualif-insert-params : qualif ‚Üí var ‚Üí var ‚Üí params ‚Üí qualif
qualif-insert-params œÉ qv v ps = trie-insert œÉ v (qv , params-to-args ps)

qualif-insert-import : qualif ‚Üí var ‚Üí optAs ‚Üí ùïÉ string ‚Üí args ‚Üí qualif
qualif-insert-import œÉ mn oa [] as = œÉ
qualif-insert-import œÉ mn oa (v :: vs) as = qualif-insert-import (trie-insert œÉ (import-as v oa) (mn # v , as)) mn oa vs as
  where
  import-as : var ‚Üí optAs ‚Üí var
  import-as v NoOptAs = v
  import-as v (SomeOptAs pi pfx) = pfx # v

tk-is-type : tk ‚Üí ùîπ
tk-is-type (Tkt _) = tt
tk-is-type (Tkk _) = ff

binder-is-pi : binder ‚Üí ùîπ
binder-is-pi Pi = tt
binder-is-pi _ = ff

lam-is-erased : lam ‚Üí ùîπ
lam-is-erased ErasedLambda = tt
lam-is-erased _ = ff

term-start-pos : term ‚Üí posinfo
type-start-pos : type ‚Üí posinfo
kind-start-pos : kind ‚Üí posinfo
liftingType-start-pos : liftingType ‚Üí posinfo

term-start-pos (App t x t‚ÇÅ) = term-start-pos t
term-start-pos (AppTp t tp) = term-start-pos t
term-start-pos (Hole pi) = pi
term-start-pos (Lam pi x _ x‚ÇÅ x‚ÇÇ t) = pi
term-start-pos (Let pi _ _) = pi
term-start-pos (Parens pi t pi') = pi
term-start-pos (Var pi x‚ÇÅ) = pi
term-start-pos (Beta pi _ _) = pi
term-start-pos (IotaPair pi _ _ _ _) = pi
term-start-pos (IotaProj t _ _) = term-start-pos t
term-start-pos (Epsilon pi _ _ _) = pi
term-start-pos (Phi pi _ _ _ _) = pi
term-start-pos (Rho pi _ _ _ _ _) = pi
term-start-pos (Chi pi _ _) = pi
term-start-pos (Delta pi _ _) = pi
term-start-pos (Sigma pi _) = pi
term-start-pos (Theta pi _ _ _) = pi

type-start-pos (Abs pi _ _ _ _ _) = pi
type-start-pos (TpLambda pi _ _ _ _) = pi
type-start-pos (Iota pi _ _ _ _) = pi
type-start-pos (Lft pi _ _ _ _) = pi
type-start-pos (TpApp t t‚ÇÅ) = type-start-pos t
type-start-pos (TpAppt t x) = type-start-pos t
type-start-pos (TpArrow t _ t‚ÇÅ) = type-start-pos t
type-start-pos (TpEq pi _ _ pi') = pi
type-start-pos (TpParens pi _ pi') = pi
type-start-pos (TpVar pi x‚ÇÅ) = pi
type-start-pos (NoSpans t _) = type-start-pos t -- we are not expecting this on input
type-start-pos (TpHole pi) = pi --ACG

kind-start-pos (KndArrow k k‚ÇÅ) = kind-start-pos k
kind-start-pos (KndParens pi k pi') = pi
kind-start-pos (KndPi pi _ x x‚ÇÅ k) = pi
kind-start-pos (KndTpArrow x k) = type-start-pos x
kind-start-pos (KndVar pi x‚ÇÅ _) = pi
kind-start-pos (Star pi) = pi

liftingType-start-pos (LiftArrow l l') = liftingType-start-pos l
liftingType-start-pos (LiftParens pi l pi') = pi
liftingType-start-pos (LiftPi pi x‚ÇÅ x‚ÇÇ l) = pi
liftingType-start-pos (LiftStar pi) = pi
liftingType-start-pos (LiftTpArrow t l) = type-start-pos t

term-end-pos : term ‚Üí posinfo
type-end-pos : type ‚Üí posinfo
kind-end-pos : kind ‚Üí posinfo
liftingType-end-pos : liftingType ‚Üí posinfo
tk-end-pos : tk ‚Üí posinfo
lterms-end-pos : lterms ‚Üí posinfo
args-end-pos : (if-nil : posinfo) ‚Üí args ‚Üí posinfo
arg-end-pos : arg ‚Üí posinfo
kvar-end-pos : posinfo ‚Üí var ‚Üí args ‚Üí posinfo

term-end-pos (App t x t') = term-end-pos t'
term-end-pos (AppTp t tp) = type-end-pos tp
term-end-pos (Hole pi) = posinfo-plus pi 1
term-end-pos (Lam pi x _ x‚ÇÅ x‚ÇÇ t) = term-end-pos t
term-end-pos (Let _ _ t) = term-end-pos t
term-end-pos (Parens pi t pi') = pi'
term-end-pos (Var pi x) = posinfo-plus-str pi x
term-end-pos (Beta pi _ (SomeTerm t pi')) = pi'
term-end-pos (Beta pi (SomeTerm t pi') _) = pi'
term-end-pos (Beta pi NoTerm NoTerm) = posinfo-plus pi 1
term-end-pos (IotaPair _ _ _ _ pi) = pi
term-end-pos (IotaProj _ _ pi) = pi
term-end-pos (Epsilon pi _ _ t) = term-end-pos t
term-end-pos (Phi _ _ _ _ pi) = pi
term-end-pos (Rho pi _ _ _ t t') = term-end-pos t'
term-end-pos (Chi pi T t') = term-end-pos t'
term-end-pos (Delta pi oT t) = term-end-pos t
term-end-pos (Sigma pi t) = term-end-pos t
term-end-pos (Theta _ _ _ ls) = lterms-end-pos ls

type-end-pos (Abs pi _ _ _ _ t) = type-end-pos t
type-end-pos (TpLambda _ _ _ _ t) = type-end-pos t
type-end-pos (Iota _ _ _ _ tp) = type-end-pos tp
type-end-pos (Lft pi _ _ _ t) = liftingType-end-pos t
type-end-pos (TpApp t t') = type-end-pos t'
type-end-pos (TpAppt t x) = term-end-pos x
type-end-pos (TpArrow t _ t') = type-end-pos t'
type-end-pos (TpEq pi _ _ pi') = pi'
type-end-pos (TpParens pi _ pi') = pi'
type-end-pos (TpVar pi x) = posinfo-plus-str pi x
type-end-pos (TpHole pi) = posinfo-plus pi 1
type-end-pos (NoSpans t pi) = pi

kind-end-pos (KndArrow k k') = kind-end-pos k'
kind-end-pos (KndParens pi k pi') = pi'
kind-end-pos (KndPi pi _ x x‚ÇÅ k) = kind-end-pos k
kind-end-pos (KndTpArrow x k) = kind-end-pos k
kind-end-pos (KndVar pi x ys) = args-end-pos (posinfo-plus-str pi x) ys
kind-end-pos (Star pi) = posinfo-plus pi 1

tk-end-pos (Tkt T) = type-end-pos T
tk-end-pos (Tkk k) = kind-end-pos k

args-end-pos pi (ArgsCons x ys) = args-end-pos (arg-end-pos x) ys
args-end-pos pi ArgsNil = pi

arg-end-pos (TermArg t) = term-end-pos t
arg-end-pos (TypeArg T) = type-end-pos T

kvar-end-pos pi v = args-end-pos (posinfo-plus-str pi v)

liftingType-end-pos (LiftArrow l l') = liftingType-end-pos l'
liftingType-end-pos (LiftParens pi l pi') = pi'
liftingType-end-pos (LiftPi x x‚ÇÅ x‚ÇÇ l) = liftingType-end-pos l
liftingType-end-pos (LiftStar pi) = posinfo-plus pi 1
liftingType-end-pos (LiftTpArrow x l) = liftingType-end-pos l

lterms-end-pos (LtermsNil pi) = posinfo-plus pi 1 -- must add one for the implicit Beta that we will add at the end
lterms-end-pos (LtermsCons _ _ ls) = lterms-end-pos ls

{- return the end position of the given term if it is there, otherwise
   the given posinfo -}
optTerm-end-pos : posinfo ‚Üí optTerm ‚Üí posinfo
optTerm-end-pos pi NoTerm = pi
optTerm-end-pos pi (SomeTerm x x‚ÇÅ) = x‚ÇÅ

optTerm-end-pos-beta : posinfo ‚Üí optTerm ‚Üí optTerm ‚Üí posinfo
optTerm-end-pos-beta pi _ (SomeTerm x pi') = pi'
optTerm-end-pos-beta pi (SomeTerm x pi') NoTerm = pi'
optTerm-end-pos-beta pi NoTerm NoTerm = posinfo-plus pi 1

optAs-or : optAs ‚Üí posinfo ‚Üí var ‚Üí posinfo √ó var
optAs-or NoOptAs pi x = pi , x
optAs-or (SomeOptAs pi x) _ _ = pi , x

tk-arrow-kind : tk ‚Üí kind ‚Üí kind
tk-arrow-kind (Tkk k) k' = KndArrow k k'
tk-arrow-kind (Tkt t) k = KndTpArrow t k

TpApp-tk : type ‚Üí var ‚Üí tk ‚Üí type
TpApp-tk tp x (Tkk _) = TpApp tp (TpVar posinfo-gen x)
TpApp-tk tp x (Tkt _) = TpAppt tp (Var posinfo-gen x)

-- expression descriptor
data exprd : Set where
  TERM : exprd
  TYPE : exprd
  KIND : exprd
  LIFTINGTYPE : exprd
  TK : exprd
  ARG : exprd
  QUALIF : exprd

‚ü¶_‚üß : exprd ‚Üí Set
‚ü¶ TERM ‚üß = term
‚ü¶ TYPE ‚üß = type
‚ü¶ KIND ‚üß = kind
‚ü¶ LIFTINGTYPE ‚üß = liftingType
‚ü¶ TK ‚üß = tk
‚ü¶ ARG ‚üß = arg
‚ü¶ QUALIF ‚üß = qualif-info

exprd-name : exprd ‚Üí string
exprd-name TERM = "term"
exprd-name TYPE = "type"
exprd-name KIND = "kind"
exprd-name LIFTINGTYPE = "lifting type"
exprd-name TK = "type-kind"
exprd-name ARG = "argument"
exprd-name QUALIF = "qualification"

-- checking-sythesizing enum
data checking-mode : Set where
  checking : checking-mode
  synthesizing : checking-mode
  untyped : checking-mode

maybe-to-checking : {A : Set} ‚Üí maybe A ‚Üí checking-mode
maybe-to-checking (just _) = checking
maybe-to-checking nothing = synthesizing

is-app : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-app{TERM} (App _ _ _) = tt
is-app{TERM} (AppTp _ _) = tt
is-app{TYPE} (TpApp _ _) = tt
is-app{TYPE} (TpAppt _ _) = tt
is-app _ = ff

is-arrow : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-arrow{TYPE} (TpArrow _ _ _) = tt
is-arrow{KIND} (KndTpArrow _ _) = tt
is-arrow{KIND} (KndArrow _ _) = tt
is-arrow{LIFTINGTYPE} (LiftArrow _ _) = tt
is-arrow{LIFTINGTYPE} (LiftTpArrow _ _) = tt
is-arrow _ = ff

is-abs : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-abs{TERM} (Let _ _ _) = tt
is-abs{TERM} (Lam _ _ _ _ _ _) = tt
is-abs{TYPE} (Abs _ _ _ _ _ _) = tt
is-abs{TYPE} (TpLambda _ _ _ _ _) = tt
is-abs{TYPE} (Iota _ _ _ _ _) = tt
is-abs{KIND} (KndPi _ _ _ _ _) = tt
is-abs{LIFTINGTYPE} (LiftPi _ _ _ _) = tt
is-abs _ = ff

is-eq-op : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-eq-op{TERM} (Sigma _ _) = tt
is-eq-op{TERM} (Epsilon _ _ _ _) = tt
is-eq-op{TERM} (Rho _ _ _ _ _ _) = tt
is-eq-op{TERM} (Chi _ _ _) = tt
is-eq-op{TERM} (Phi _ _ _ _ _) = tt
is-eq-op _ = ff

is-beta : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-beta{TERM} (Beta _ _ _) = tt
is-beta _ = ff

eq-maybeErased : maybeErased ‚Üí maybeErased ‚Üí ùîπ
eq-maybeErased Erased Erased = tt
eq-maybeErased Erased NotErased = ff
eq-maybeErased NotErased Erased = ff
eq-maybeErased NotErased NotErased = tt

eq-lam : lam ‚Üí lam ‚Üí ùîπ
eq-lam ErasedLambda ErasedLambda = tt
eq-lam ErasedLambda KeptLambda = ff
eq-lam KeptLambda ErasedLambda = ff
eq-lam KeptLambda KeptLambda = tt

eq-binder : binder ‚Üí binder ‚Üí ùîπ
eq-binder All All = tt
eq-binder Pi Pi = tt
eq-binder _ _ = ff

eq-arrowtype : arrowtype ‚Üí arrowtype ‚Üí ùîπ
eq-arrowtype ErasedArrow ErasedArrow = tt
eq-arrowtype UnerasedArrow UnerasedArrow = tt
eq-arrowtype _ _ = ff

arrowtype-matches-binder : arrowtype ‚Üí binder ‚Üí ùîπ
arrowtype-matches-binder ErasedArrow All = tt
arrowtype-matches-binder UnerasedArrow Pi = tt
arrowtype-matches-binder _ _ = ff

optPublic-is-public : optPublic ‚Üí ùîπ
optPublic-is-public IsPublic = tt
optPublic-is-public NotPublic = ff

------------------------------------------------------
-- functions intended for building terms for testing
------------------------------------------------------
mlam : var ‚Üí term ‚Üí term
mlam x t = Lam posinfo-gen KeptLambda posinfo-gen x NoClass t

Mlam : var ‚Üí term ‚Üí term
Mlam x t = Lam posinfo-gen ErasedLambda posinfo-gen x NoClass t

mappe : term ‚Üí term ‚Üí term
mappe t1 t2 = App t1 Erased t2

mapp : term ‚Üí term ‚Üí term
mapp t1 t2 = App t1 NotErased t2

mvar : var ‚Üí term
mvar x = Var posinfo-gen x

mtpvar : var ‚Üí type
mtpvar x = TpVar posinfo-gen x

mall : var ‚Üí tk ‚Üí type ‚Üí type
mall x tk tp = Abs posinfo-gen All posinfo-gen x tk tp

mtplam : var ‚Üí tk ‚Üí type ‚Üí type
mtplam x tk tp = TpLambda posinfo-gen posinfo-gen x tk tp

{- strip off lambda-abstractions from the term, return the lambda-bound vars and the innermost body.
   The intention is to call this with at least the erasure of a term, if not the hnf -- so we do
   not check for parens, etc. -}
decompose-lams : term ‚Üí (ùïÉ var) √ó term
decompose-lams (Lam _ _ _ x _ t) with decompose-lams t
decompose-lams (Lam _ _ _ x _ t) | vs , body = (x :: vs) , body
decompose-lams t = [] , t

{- decompose a term into spine form consisting of a non-applications head and arguments.
   The outer arguments will come earlier in the list than the inner ones.
   As for decompose-lams, we assume the term is at least erased. -}
decompose-apps : term ‚Üí term √ó (ùïÉ term)
decompose-apps (App t _ t') with decompose-apps t
decompose-apps (App t _ t') | h , args = h , (t' :: args)
decompose-apps t = t , []

decompose-var-headed : (var ‚Üí ùîπ) ‚Üí term ‚Üí maybe (var √ó (ùïÉ term))
decompose-var-headed is-bound t with decompose-apps t
decompose-var-headed is-bound t | Var _ x , args = if is-bound x then nothing else (just (x , args))
decompose-var-headed is-bound t | _ = nothing

data tty : Set where
  tterm : term ‚Üí tty
  ttype : type ‚Üí tty

decompose-tpapps : type ‚Üí type √ó ùïÉ tty 
decompose-tpapps (TpApp t t') with decompose-tpapps t
decompose-tpapps (TpApp t t') | h , args = h , (ttype t') :: args
decompose-tpapps (TpAppt t t') with decompose-tpapps t
decompose-tpapps (TpAppt t t') | h , args = h , (tterm t') :: args
decompose-tpapps (TpParens _ t _) = decompose-tpapps t
decompose-tpapps t = t , []

recompose-tpapps : type √ó ùïÉ tty ‚Üí type
recompose-tpapps (h , []) = h
recompose-tpapps (h , ((tterm t') :: args)) = TpAppt (recompose-tpapps (h , args)) t'
recompose-tpapps (h , ((ttype t') :: args)) = TpApp (recompose-tpapps (h , args)) t'

vars-to-ùïÉ : vars ‚Üí ùïÉ var
vars-to-ùïÉ (VarsStart v) = [ v ]
vars-to-ùïÉ (VarsNext v vs) = v :: vars-to-ùïÉ vs

{- lambda-abstract the input variables in reverse order around the
   given term (so closest to the top of the list is bound deepest in
   the resulting term). -}
Lam* : ùïÉ var ‚Üí term ‚Üí term
Lam* [] t = t
Lam* (x :: xs) t = Lam* xs (Lam posinfo-gen KeptLambda posinfo-gen x NoClass t)

App* : term ‚Üí ùïÉ (maybeErased √ó term) ‚Üí term
App* t [] = t
App* t ((m , arg) :: args) = App (App* t args) m arg

App*' : term ‚Üí ùïÉ term ‚Üí term
App*' t [] = t
App*' t (arg :: args) = App*' (App t NotErased arg) args

TpApp* : type ‚Üí ùïÉ type ‚Üí type
TpApp* t [] = t
TpApp* t (arg :: args) = (TpApp (TpApp* t args) arg)

LiftArrow* : ùïÉ liftingType ‚Üí liftingType ‚Üí liftingType
LiftArrow* [] l = l
LiftArrow* (l' :: ls) l = LiftArrow* ls (LiftArrow l' l)

is-intro-form : term ‚Üí ùîπ
is-intro-form (Lam _ _ _ _ _ _) = tt
--is-intro-form (IotaPair _ _ _ _ _) = tt
is-intro-form _ = ff

erase : { ed : exprd } ‚Üí ‚ü¶ ed ‚üß ‚Üí ‚ü¶ ed ‚üß
erase-term : term ‚Üí term
erase-type : type ‚Üí type
erase-kind : kind ‚Üí kind
erase-lterms : theta ‚Üí lterms ‚Üí ùïÉ term
erase-tk : tk ‚Üí tk
-- erase-optType : optType ‚Üí optType
erase-liftingType : liftingType ‚Üí liftingType

erase-if : ùîπ ‚Üí { ed : exprd } ‚Üí ‚ü¶ ed ‚üß ‚Üí ‚ü¶ ed ‚üß
erase-if tt = erase
erase-if ff = id

erase-term (Parens _ t _) = erase-term t
erase-term (App t1 Erased t2) = erase-term t1
erase-term (App t1 NotErased t2) = App (erase-term t1) NotErased (erase-term t2)
erase-term (AppTp t tp) = erase-term t
erase-term (Lam _ ErasedLambda _ _ _ t) = erase-term t
erase-term (Let pi (DefTerm pi'' x _ t) t') = Let pi (DefTerm pi'' x NoCheckType (erase-term t)) (erase-term t')
erase-term (Let _ (DefType _ _ _ _) t) = erase-term t
erase-term (Lam pi KeptLambda pi' x oc t) = Lam pi KeptLambda pi' x NoClass (erase-term t)
erase-term (Var pi x) = Var pi x
erase-term (Beta pi _ NoTerm) = id-term
erase-term (Beta pi _ (SomeTerm t _)) = erase-term t
erase-term (IotaPair pi t1 t2 _ pi') = erase-term t1
erase-term (IotaProj t n pi) = erase-term t
erase-term (Epsilon pi lr _ t) = erase-term t
erase-term (Sigma pi t) = erase-term t
erase-term (Hole pi) = Hole pi
erase-term (Phi pi t t‚ÇÅ t‚ÇÇ pi') = erase-term t‚ÇÇ
erase-term (Rho pi _ _ t _ t') = erase-term t'
erase-term (Chi pi T t') = erase-term t'
erase-term (Delta pi T t) = erase-term t
erase-term (Theta pi u t ls) = App*' (erase-term t) (erase-lterms u ls)

-- Only erases TERMS in types, leaving the structure of types the same
erase-type (Abs pi b pi' v t-k tp) = Abs pi b pi' v (erase-tk t-k) (erase-type tp)
erase-type (Iota pi pi' v otp tp) = Iota pi pi' v (erase-type otp) (erase-type tp)
erase-type (Lft pi pi' v t lt) = Lft pi pi' v (erase-term t) (erase-liftingType lt)
erase-type (NoSpans tp pi) = NoSpans (erase-type tp) pi
erase-type (TpApp tp tp') = TpApp (erase-type tp) (erase-type tp')
erase-type (TpAppt tp t) = TpAppt (erase-type tp) (erase-term t)
erase-type (TpArrow tp at tp') = TpArrow (erase-type tp) at (erase-type tp')
erase-type (TpEq pi t t' pi') = TpEq pi (erase-term t) (erase-term t') pi'
erase-type (TpLambda pi pi' v t-k tp) = TpLambda pi pi' v (erase-tk t-k) (erase-type tp)
erase-type (TpParens pi tp pi') = TpParens pi (erase-type tp) pi'
erase-type (TpHole pi) = TpHole pi
erase-type (TpVar pi x) = TpVar pi x

-- Only erases TERMS in types in kinds, leaving the structure of kinds and types in those kinds the same
erase-kind (KndArrow k k') = KndArrow (erase-kind k) (erase-kind k')
erase-kind (KndParens pi k pi') = KndParens pi (erase-kind k) pi'
erase-kind (KndPi pi pi' v t-k k) = KndPi pi pi' v (erase-tk t-k) (erase-kind k)
erase-kind (KndTpArrow tp k) = KndTpArrow (erase-type tp) (erase-kind k)
erase-kind (KndVar pi x ps) = KndVar pi x ps
erase-kind (Star pi) = Star pi

erase{TERM} t = erase-term t
erase{TYPE} tp = erase-type tp
erase{KIND} k = erase-kind k
erase{LIFTINGTYPE} lt = erase-liftingType lt
erase{TK} atk = erase-tk atk
erase{ARG} a = a
erase{QUALIF} q = q

erase-tk (Tkt tp) = Tkt (erase-type tp)
erase-tk (Tkk k) = Tkk (erase-kind k)

-- erase-optType (SomeType tp) = SomeType (erase-type tp)
-- erase-optType NoType = NoType

erase-liftingType (LiftArrow lt lt') = LiftArrow (erase-liftingType lt) (erase-liftingType lt')
erase-liftingType (LiftParens pi lt pi') = LiftParens pi (erase-liftingType lt) pi'
erase-liftingType (LiftPi pi v tp lt) = LiftPi pi v (erase-type tp) (erase-liftingType lt)
erase-liftingType (LiftTpArrow tp lt) = LiftTpArrow (erase-type tp) (erase-liftingType lt)
erase-liftingType lt = lt

erase-lterms Abstract (LtermsNil _) = []
erase-lterms (AbstractVars _) (LtermsNil _) = []
erase-lterms AbstractEq (LtermsNil pi) = [ Beta pi NoTerm NoTerm ]
erase-lterms u (LtermsCons NotErased t ls) = (erase-term t) :: erase-lterms u ls
erase-lterms u (LtermsCons Erased t ls) = erase-lterms u ls

lterms-to-ùïÉh : theta ‚Üí lterms ‚Üí ùïÉ (maybeErased √ó term)
lterms-to-ùïÉh Abstract (LtermsNil _) = []
lterms-to-ùïÉh (AbstractVars _) (LtermsNil _) = []
lterms-to-ùïÉh AbstractEq (LtermsNil pi) = [ NotErased , Beta pi NoTerm NoTerm ]
lterms-to-ùïÉh u (LtermsCons m t ls) = (m , t) :: (lterms-to-ùïÉh u ls)

lterms-to-ùïÉ : theta ‚Üí lterms ‚Üí ùïÉ (maybeErased √ó term)
lterms-to-ùïÉ u ls = reverse (lterms-to-ùïÉh u ls)

lterms-to-ùïÉ' : theta ‚Üí lterms ‚Üí ùïÉ term
lterms-to-ùïÉ' u ls = map snd (lterms-to-ùïÉ u ls)

erase-lterms-if : ùîπ ‚Üí theta ‚Üí lterms ‚Üí ùïÉ term
erase-lterms-if tt = erase-lterms
erase-lterms-if ff t lt = lterms-to-ùïÉ' t lt

{-
num-to-‚Ñï : num ‚Üí ‚Ñï
num-to-‚Ñï n with string-to-‚Ñï n
num-to-‚Ñï _ | just n = n
num-to-‚Ñï _ | _ = 0
-}

imps-to-cmds : imports ‚Üí cmds
imps-to-cmds ImportsStart = CmdsStart
imps-to-cmds (ImportsNext i is) = CmdsNext (ImportCmd i) (imps-to-cmds is)

-- TODO handle qualif & module args
get-imports : start ‚Üí ùïÉ string
get-imports (File _ is _ _ mn _ cs _) = imports-to-include is ++ get-imports-cmds cs
  where import-to-include : imprt ‚Üí string
        import-to-include (Import _ _ _ x oa _ _) = x
        imports-to-include : imports ‚Üí ùïÉ string
        imports-to-include ImportsStart = []
        imports-to-include (ImportsNext x is) = import-to-include x :: imports-to-include is
        singleton-if-include : cmd ‚Üí ùïÉ string
        singleton-if-include (ImportCmd imp) = [ import-to-include imp ]
        singleton-if-include _ = []
        get-imports-cmds : cmds ‚Üí ùïÉ string
        get-imports-cmds (CmdsNext c cs) = singleton-if-include c ++ get-imports-cmds cs
        get-imports-cmds CmdsStart = []

data language-level : Set where
  ll-term : language-level
  ll-type : language-level
  ll-kind : language-level

ll-to-string : language-level ‚Üí string
ll-to-string ll-term = "term"
ll-to-string ll-type = "type"
ll-to-string ll-kind = "kind"

is-rho-plus : optPlus ‚Üí ùîπ
is-rho-plus RhoPlus = tt
is-rho-plus _ = ff

is-equation : {ed : exprd} ‚Üí ‚ü¶ ed ‚üß ‚Üí ùîπ
is-equation{TYPE} (TpParens _ t _) = is-equation t
is-equation{TYPE} (TpEq _ _ _ _) = tt
is-equation _ = ff 

is-equational : type ‚Üí ùîπ
is-equational-kind : kind ‚Üí ùîπ
is-equational-tk : tk ‚Üí ùîπ
is-equational (Abs _ _ _ _ atk t2) = is-equational-tk atk || is-equational t2
is-equational (Iota _ _ _ t1 t2) = is-equational t1 || is-equational t2
is-equational (NoSpans t _) = is-equational t
is-equational (TpApp t1 t2) = is-equational t1 || is-equational t2
is-equational (TpAppt t1 _) = is-equational t1
is-equational (TpArrow t1 _ t2) = is-equational t1 || is-equational t2
is-equational (TpEq _ _ _ _) = tt
is-equational (TpLambda _ _ _ atk t2) = is-equational-tk atk || is-equational t2
is-equational (TpParens _ t _) = is-equational t
is-equational (Lft _ _ _ _ _) = ff
is-equational (TpVar _ t) = ff
is-equational (TpHole _) = ff --ACG
is-equational-tk (Tkt t1) = is-equational t1
is-equational-tk (Tkk k) = is-equational-kind k
is-equational-kind (KndArrow k1 k2) = is-equational-kind k1 || is-equational-kind k2
is-equational-kind (KndParens _ k _) = is-equational-kind k
is-equational-kind (KndPi _ _ _ atk k) = is-equational-tk atk || is-equational-kind k
is-equational-kind (KndTpArrow t1 k2) = is-equational t1 || is-equational-kind k2
is-equational-kind (KndVar _ _ _) = ff
is-equational-kind (Star _) = ff

split-var-h : ùïÉ char ‚Üí ùïÉ char √ó ùïÉ char
split-var-h [] = [] , []
split-var-h ('.' :: xs) = [] , xs
split-var-h (x :: xs) with split-var-h xs
... | xs' , ys = (x :: xs') , ys

split-var : var ‚Üí var √ó var
split-var v with split-var-h (reverse (string-to-ùïÉchar v))
... | xs , ys = ùïÉchar-to-string (reverse ys) , ùïÉchar-to-string (reverse xs)

var-suffix : var ‚Üí maybe var
var-suffix v with split-var v
... | "" , _ = nothing
... | _ , sfx = just sfx

-- unique qualif domain prefixes
qual-pfxs : qualif ‚Üí ùïÉ var
qual-pfxs q = uniq (prefixes (trie-strings q))
  where
  uniq : ùïÉ var ‚Üí ùïÉ var
  uniq vs = stringset-strings (stringset-insert* empty-stringset vs)
  prefixes : ùïÉ var ‚Üí ùïÉ var
  prefixes [] = []
  prefixes (v :: vs) with split-var v
  ... | "" , sfx = vs
  ... | pfx , sfx = pfx :: prefixes vs

unqual-prefix : qualif ‚Üí ùïÉ var ‚Üí var ‚Üí var ‚Üí var
unqual-prefix q [] sfx v = v
unqual-prefix q (pfx :: pfxs) sfx v
  with trie-lookup q (pfx # sfx)
... | just (v' , _) = if v =string v' then pfx # sfx else v
... | nothing = v

unqual-bare : qualif ‚Üí var ‚Üí var ‚Üí var
unqual-bare q sfx v with trie-lookup q sfx
... | just (v' , _) = if v =string v' then sfx else v
... | nothing = v

unqual-local : var ‚Üí var
unqual-local v = f (string-to-ùïÉchar v) [] where
  f : ùïÉ char ‚Üí ùïÉ char ‚Üí string
  f [] acc = ùïÉchar-to-string (reverse acc)
  f ('@' :: t) acc = f t []
  f (h :: t) acc = f t (h :: acc)

unqual-all : qualif ‚Üí var ‚Üí string
unqual-all q v with var-suffix v
... | nothing = v
... | just sfx = unqual-bare q sfx (unqual-prefix q (qual-pfxs q) sfx v)

lam-expand-term : params ‚Üí term ‚Üí term
lam-expand-term (ParamsCons (Decl pi pi' x tk@(Tkt _) _) ps) t =
  Lam posinfo-gen KeptLambda pi' x NoClass (lam-expand-term ps t)
lam-expand-term (ParamsCons (Decl pi pi' x tk@(Tkk _) _) ps) t =
  lam-expand-term ps t
lam-expand-term ParamsNil t = t

lam-expand-type : params ‚Üí type ‚Üí type
lam-expand-type (ParamsCons (Decl pi pi' x tk _) ps) t =
  TpLambda posinfo-gen pi' x tk (lam-expand-type ps t)
lam-expand-type ParamsNil t = t

abs-expand-type : params ‚Üí type ‚Üí type
abs-expand-type (ParamsCons (Decl pi pi' x tk _) ps) t =
  Abs posinfo-gen Pi pi' x tk (abs-expand-type ps t)
abs-expand-type ParamsNil t = t

abs-expand-kind : params ‚Üí kind ‚Üí kind
abs-expand-kind (ParamsCons (Decl pi pi' x tk _) ps) k =
  KndPi posinfo-gen pi' x tk (abs-expand-kind ps k)
abs-expand-kind ParamsNil k = k

args-length : args ‚Üí ‚Ñï
args-length (ArgsCons p ps) = suc (args-length ps)
args-length ArgsNil = 0

erased-args-length : args ‚Üí ‚Ñï
erased-args-length (ArgsCons (TermArg _) ps) = suc (erased-args-length ps)
erased-args-length (ArgsCons (TypeArg _) ps) = erased-args-length ps
erased-args-length ArgsNil = 0

me-args-length : maybeErased ‚Üí args ‚Üí ‚Ñï
me-args-length Erased = erased-args-length
me-args-length NotErased = args-length

spine : Set
spine = ùïÉ(maybeErased √ó arg)

spineApp : Set
spineApp = (posinfo √ó qvar) √ó spine

term-to-spapp : term ‚Üí maybe spineApp
term-to-spapp (App t me t') = term-to-spapp t ‚â´=maybe
  (Œª { (v , as) ‚Üí just (v , (me , TermArg t') :: as) })
term-to-spapp (AppTp t T) = term-to-spapp t ‚â´=maybe
  (Œª { (v , as) ‚Üí just (v , (NotErased , TypeArg T) :: as) })
term-to-spapp (Var pi v) = just ((pi , v) , [])
term-to-spapp _ = nothing

type-to-spapp : type ‚Üí maybe spineApp
type-to-spapp (TpApp T T') = type-to-spapp T ‚â´=maybe
  (Œª { (v , as) ‚Üí just (v , (NotErased , TypeArg T') :: as) })
type-to-spapp (TpAppt T t) = type-to-spapp T ‚â´=maybe
  (Œª { (v , as) ‚Üí just (v , (NotErased , TermArg t) :: as) })
type-to-spapp (TpVar pi v) = just ((pi , v) , [])
type-to-spapp _ = nothing

spapp-term : spineApp ‚Üí term
spapp-term ((pi , v) , []) = Var pi v
spapp-term (v , (me , TermArg t) :: as) = App (spapp-term (v , as)) me t
spapp-term (v , (me , TypeArg T) :: as) = AppTp (spapp-term (v , as)) T

spapp-type : spineApp ‚Üí type
spapp-type ((pi , v) , []) = TpVar pi v
spapp-type (v , (me , TermArg t) :: as) = TpAppt (spapp-type (v , as)) t
spapp-type (v , (me , TypeArg T) :: as) = TpApp (spapp-type (v , as)) T

num-gt : num ‚Üí ‚Ñï ‚Üí ùïÉ string
num-gt n n' = maybe-else [] (Œª n'' ‚Üí if n'' > n' then [ n ] else []) (string-to-‚Ñï n)
nums-gt : nums ‚Üí ‚Ñï ‚Üí ùïÉ string
nums-gt (NumsStart n) n' = num-gt n n'
nums-gt (NumsNext n ns) n' =
  maybe-else [] (Œª n'' ‚Üí if n'' > n' || iszero n'' then [ n ] else []) (string-to-‚Ñï n)
  ++ nums-gt ns n'

nums-to-stringset : nums ‚Üí stringset √ó ùïÉ string {- Repeated numbers -}
nums-to-stringset (NumsStart n) = stringset-insert empty-stringset n , []
nums-to-stringset (NumsNext n ns) with nums-to-stringset ns
...| ss , rs = if stringset-contains ss n
  then ss , n :: rs
  else stringset-insert ss n , rs

optNums-to-stringset : optNums ‚Üí maybe stringset √ó (‚Ñï ‚Üí maybe string)
optNums-to-stringset NoNums = nothing , Œª _ ‚Üí nothing
optNums-to-stringset (SomeNums ns) with nums-to-stringset ns
...| ss , [] = just ss , Œª n ‚Üí case nums-gt ns n of Œª where
  [] ‚Üí nothing
  ns-g ‚Üí just ("Occurrences not found: " ^ ùïÉ-to-string id ", " ns-g ^ " (total occurrences: " ^ ‚Ñï-to-string n ^ ")")
...| ss , rs = just ss , Œª n ‚Üí
  just ("The list of occurrences contains the following repeats: " ^ ùïÉ-to-string id ", " rs)
