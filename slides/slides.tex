\documentclass[mathserif,usenames,dvipsnames]{beamer}
\usetheme{Warsaw}
\usepackage{proof}
\usepackage{cancel}
\usepackage{hyperref}
\usepackage{textgreek}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage[greek,english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{fancyvrb}


\title{Generic Zero-Cost Reuse for Dependent Types}
\author{Larry Diehl, Denis Firsov, and Aaron Stump}
\institute{University of Iowa}
\date[September 26, 2018]
{ICFP 2018}

\DeclareUnicodeCharacter{2261}{\ensuremath{\equiv}}
\DeclareUnicodeCharacter{25CF}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{2200}{\ensuremath{\forall}}
\DeclareUnicodeCharacter{2605}{\ensuremath{\star}}
\DeclareUnicodeCharacter{2794}{\ensuremath{\rightarrow}}
\DeclareUnicodeCharacter{2243}{\ensuremath{\simeq}}
\DeclareUnicodeCharacter{03A0}{\ensuremath{\mathrm{\Pi}}}
\DeclareUnicodeCharacter{03BB}{\textlambda}
\DeclareUnicodeCharacter{923}{\textLambda}
\DeclareUnicodeCharacter{25C2}{\ensuremath{\blacktriangleleft}}
\DeclareUnicodeCharacter{27BE}{\ensuremath{\Rightarrow}}
\DeclareUnicodeCharacter{2218}{\ensuremath{\circ}}
\DeclareUnicodeCharacter{2081}{$_1$}
\DeclareUnicodeCharacter{2082}{$_2$}
\DeclareUnicodeCharacter{7522}{$_i$}

\newcommand{\look}[1]{\textcolor{blue}{#1}}

\newcommand{\abs}[4]{{#1}\, #2\! : \! #3.\, #4}
\newcommand{\lam}[2]{\lambda\, #1.\, #2}

\newcommand{\txt}[1]{\ensuremath{\texttt{#1}}}
\newcommand{\arr}[0]{\ensuremath{\rightarrow}}
\newcommand{\nat}[0]{\ensuremath{\mathbb{N}}}

\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{Problem}

Dependently typed programming involves using differently indexed
versions of the same underlying data structures. This leads to
\textbf{code duplication}, where functions over essentially the same
data must be rewritten for each version of the type.

\end{frame}

\begin{frame}
\frametitle{Goal}

We would like to reuse code between non-indexed and indexed (or
differently indexed) types:

\begin{itemize}
\item Given a function over a non-indexed type,
  we want to produce the indexed variant (or vice versa).
\item Additionally, we want to avoid any runtime performance penalty
  when applying reused functions.
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Various List Types}

\begin{center}
\begin{tabular}{ |c||l| } 
 \hline
 Lists & \texttt{List ◂ ★ ➔ ★} \\
 \hline
 Length-indexed & \texttt{Vec ◂ ★ ➔ Nat ➔ ★} \\
 \hline
 Ordered & \texttt{OList ◂ ★ ➔ Bnd ➔ Bnd ➔ ★} \\ 
 \hline
 Ordered \& len.-ind. & \texttt{OVec ◂ ★ ➔ Bnd ➔ Bnd ➔ Nat ➔ ★} \\ 
 \hline
\end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]
\frametitle{Various List Append Types}

\begin{verbatim}
appL ◂ ∀ A : ★. List A ➔ List A ➔ List A

appV ◂ ∀ A : ★. ∀ n,m : Nat. 
  Vec A n ➔ Vec A m ➔ Vec A (add n m)

appOL ◂ ∀ A : ★. ∀ b1,b2,b3 : Bnd. 
  OList A b1 b2 ➔ OList b2 b3 ➔ OList A b1 b3

appOV ◂ ∀ A : ★. ∀ b1,b2,b3 : Bnd. ∀ n,m : Nat.
  OVec A b1 b2 n ➔ OVec A m b2 b3 ➔ 
  OVec A b1 b3 (add n m)
\end{verbatim}

\noindent\rule{\textwidth}{1pt}

\begin{verbatim}
appL = appV = appOL = appOV
\end{verbatim}

\end{frame}

\begin{frame}[fragile]
\frametitle{Various STLC and Substitution Types}

\begin{verbatim}
Raw ◂ ★

Term ◂ Ctx ➔ Tp ➔ ★
\end{verbatim}

\noindent\rule{\textwidth}{1pt}

\begin{verbatim}
subR ◂ List Raw ➔ Raw ➔ Raw

subT ◂ ∀ Γ,Δ : Ctx. ∀ A : Tp.
  Env Γ Δ ➔ Term Γ A ➔ Term Δ A
\end{verbatim}

\noindent\rule{\textwidth}{1pt}

\begin{verbatim}
subR = suTb
\end{verbatim}

\end{frame}

\begin{frame}[fragile]
\frametitle{Solution: Extrinsic Typing}

Consider an extrinsically typed (or Curry-style) theory, where the
same term may be typed multiple different ways. In such a theory,
there is no cost to convert between lists and vectors, or functions
over them, because the terms are the same to begin with.

\end{frame}

\begin{frame}[fragile]
\frametitle{Extrinsic Typing of Constructors}

\begin{verbatim}
List ◂ ★ ➔ ★ = λ A. ∀ X : ★. X ➔ (A ➔ X ➔ X) ➔ X.

Vec ◂ ★ ➔ Nat ➔ ★ = λ A,n. ∀ X : Nat ➔ ★.
  X zero ➔ (∀ n : Nat. A ➔ X n ➔ X (suc n)) ➔ X n.
\end{verbatim}

\noindent\rule{\textwidth}{1pt}

\begin{verbatim}
nil ≡ λ cN,cC. cN
cons ≡ λ x,xs,cN,cC. cC x (xs cN cC)

nil : ∀ A : ★. List A
cons : ∀ A : ★. A ➔ List A ➔ List A

nil : ∀ A : ★. Vec A zero
cons : ∀ A : ★. ∀ n : Nat. A ➔ Vec A n ➔ Vec A (suc n)
\end{verbatim}

\end{frame}

\begin{frame}[fragile]
\frametitle{Extrinsic Typing of Functions}

\begin{verbatim}
List ◂ ★ ➔ ★ = λ A. ∀ X : ★. X ➔ (A ➔ X ➔ X) ➔ X.

Vec ◂ ★ ➔ Nat ➔ ★ = λ A,n. ∀ X : Nat ➔ ★.
  X zero ➔ (∀ n : Nat. A ➔ X n ➔ X (suc n)) ➔ X n.
\end{verbatim}

\noindent\rule{\textwidth}{1pt}

\begin{verbatim}
app ≡ λ xs. xs (λ ys. ys) 
  (λ x,ih,ys,cN,cC. cC x (ih ys cN cC))

app : ∀ A : ★. List A ➔ List A ➔ List A

app : ∀ A : ★. ∀ n,m : Nat. 
  Vec A n ➔ Vec A m ➔ Vec A (add n m)
\end{verbatim}

\end{frame}

\begin{frame}[fragile]
\frametitle{Solution: Extrinsic Typing}

\begin{block}{Assignment vs Annotation}
Type checking is non-algorithmic for \textbf{type-assignment} systems, so they
are not useful as programming languages. Thus, we solve our problem in
CDLE (Cedille), which has an algorithmic type checker due because it
is a \textbf{type-annotated} version of an extrinsic type theory.
\end{block}

\begin{block}{Zero-Cost Reuse}
In a type-annotated setting, the constructors and functions for lists
and vectors are different, but their \textit{erasures} are the
same. Our solution to zero-cost reuse allows the user to reuse a list
as a vector (or a list function as a vector function), or vice versa,
without a performance penalty because the erasures of the reused term
will be equal to the erasure of the original term.
\end{block}

\end{frame}

\begin{frame}
\frametitle{CDLE (Cedille)}
\framesubtitle{Curry-Style Impredicative Calculus of Constructions + 3 Primitive Types}

\begin{center}
\begin{tabular}{ |c||c| } 
 \hline
 Implicit Product & \texttt{∀ x : T. T'} \\
 \hline
 Heterogeneous Equality & \texttt{t ≃ t'} \\
 \hline
 Dependent Intersection & \texttt{ι x : T. T'} \\
 \hline
\end{tabular}
\end{center}

\end{frame}

\begin{frame}
\frametitle{CDLE (Cedille)}
\framesubtitle{Typing Rules}

\begin{figure}
\centering
\[
\begin{array}{cc}
  \look{\infer{\Gamma\vdash \abs{\Lambda}{x}{T'}{t} : \abs{\forall}{x}{T'}{T}}{\Gamma,x:T'\vdash t : T & \!\!x\not\in\textit{FV}(|t|)}} & 
  \look{\infer{\Gamma\vdash t\ -t' : [t'/x]T}{\Gamma\vdash t : \abs{\forall}{x}{T'}{T} & \Gamma\vdash t':T'}} \\ \\

  \infer{\Gamma\vdash \beta : t \simeq t}{\Gamma\vdash t : T} &
  \infer{\Gamma\vdash \rho\ q\ -\ t : [t_2/x]T}{\Gamma\vdash q : t_1 \simeq t_2 & \Gamma \vdash t : [t_1/x]T} \\ \\

  \infer{\Gamma\vdash \phi\ q\ -\ t_1 \{t_2\} : T}{\Gamma\vdash q : t_1 \simeq t_2 & \Gamma \vdash t_1 : T} &
  \infer{\Gamma\vdash [t_1,t_2] : \abs{\iota}{x}{T}{T'}}{\Gamma\vdash t_1 : T & \Gamma\vdash t_2 : [t_1/x]T' & |t_1| = |t_2|} \\ \\

  \infer{\Gamma\vdash t.1 : T}{\Gamma\vdash t : \abs{\iota}{x}{T}{T'}} &
  \infer{\Gamma\vdash t.2 : [t.1/x]T'}{\Gamma\vdash t : \abs{\iota}{x}{T}{T'}} \\ \\

\end{array}
\]
\end{figure}
\end{frame}

\begin{frame}
\frametitle{CDLE (Cedille)}
\framesubtitle{Erasure Rules}

\begin{figure}
\centering
\[
  \begin{array}{lll}
    \look{|\abs{\Lambda}{x}{T}{t}|} & \look{=} & \look{|t|} \\
    \look{|t\ -t'|} & \look{=} & \look{|t|} \\
    |\beta| & = & \lam{x}{x} \\
    |\rho\ q\ - \ t| & = & |t| \\
    |\phi\ q\ - \ t_1 \{t_2\}| & = & |t_2| \\
    |[t_1,t_2]| & = & |t_1| \\
    |t.1| & = & |t| \\
    |t.2| & = & |t| 
  \end{array}
  \]
\end{figure}
\end{frame}

\end{document}
